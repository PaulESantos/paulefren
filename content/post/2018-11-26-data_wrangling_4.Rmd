---
title: "Data Wrangling Part 4"
subtitle: "Agrupamiento y tablas resumen"
author: "Paul Efren Santos Andrade"
date: 2018-11-26
categories: ["R"]
tags: ["R Markdown", "Data management"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, error = FALSE, warning=FALSE)
library(tidyverse)
library(knitr)
library(infer)
```

## La base de datos  

Continuamos trabajando con el data.frame **msleep**, siempre con la intención de permitir la reproductibilidad del código.

```{r eval=FALSE}
glimpse(msleep)
```

```{r echo=FALSE}
data(msleep)
glimpse(msleep)
```


## Recuento de eventos:

- **Número de observaciónes**:

Determinar el número de observaciones para cada uno de los niveles de una variable específica, es una tarea que puede ser completada fácilmente con la función `count()`.
Uno de los argumentos útiles de esta función es: `sort = TRUE`, el cual nos permite ordenar los resultados en forma decreciente:


```{r eval=FALSE}
msleep %>% 
  count(order, sort = TRUE)
```

```{r}
msleep %>% 
  count(order, sort = TRUE) %>% 
  head(n = 10) %>% 
  kable()
```



La función **count()** puede actuar sobre múltiples variables, el siguiente ejemplo cuenta el número de observaciones para cada uno de los niveles de las variables **order** y **vore**:


```{r eval=FALSE}
msleep %>% 
  count(order, vore, sort = TRUE)
```

```{r echo=FALSE}
msleep %>% 
  count(order, vore, sort = TRUE) %>% 
  head(n = 10) %>% 
  kable()
```


- **Adjuntando el número de observaciones en una nueva columna:**

Si el interés es solo conocer el número total de observaciones en el data.frame, la función **tally()** puede ayudar con esta tarea. Esta función es homologa con **nrow()**.Esta función  no puede ser utilizada sobre variables específicas.

```{r eval=FALSE}
msleep %>% 
  tally()
---
msleep %>% 
  nrow()
```

- tally()

```{r echo=FALSE}
msleep %>% 
  tally() %>% 
  kable()
```

- nrow()

```{r echo=FALSE}
msleep %>% 
  nrow() %>% 
  kable()
```

La función **add_tally()** crea una nueva columna con el número total de observaciones, semejante a **mutate(n = n())**.

```{r eval=FALSE}
msleep %>% 
  select(1:3) %>% 
  add_tally()
```

```{r echo=FALSE}
msleep %>% 
  select(1:3) %>% 
  add_tally() %>% 
  head() %>% 
  kable()
```


La función **add_count()** toma como argumento una variable y crea una nueva columna con el número de observaciones para cada uno de sus niveles:

```{r eval=FALSE}
msleep %>% 
  select(name:vore) %>% 
  add_count(vore)
```

```{r echo=FALSE}
msleep %>% 
  select(name:vore) %>% 
  add_count(vore) %>% 
  head(n = 10) %>% 
  kable()
```



## summarise() - summarize()

- **Construyendo tablas de resumen**


- Nota: Algunas de las funciones en **dplyr()** son nombradas tanto en **Ingles Americano** como **Ingles Británico**. Así la función **summarise()** es equivalente a **summarize()**.

Como ya observamos líneas antes; si el interés es conocer el número de observaciones, la función  `count()` puede cumplir esa tarea. Pero si buscamos conocer el promedio, la suma, el mínimo, el máximo y el número de observaciones necesitaremos apoyarnos en otra función. La función *summarize()* permitirá alcanzar este objetivo. Esta función necesita como argumentos:

1.	El nombre de la nueva columna.
2.	El operador de asignación igual `("=")`.
3.	La función que se desea aplicar sobre la variable.

**data_frame %>%
summarise(nombre_columna = función(variable))**


Es posible utilizar múltiples funciones, una seguida de otra:

```{r eval=FALSE}
msleep %>% 
  summarise(n = n(),
            promedio = mean(sleep_total),
            maximo = max(sleep_total))
```

```{r echo=FALSE}
msleep %>% 
  summarise(n = n(),
            promedio = mean(sleep_total),
            maximo = max(sleep_total)) %>% 
  kable()
```

## group_by()

En muchas oportunidades es necesario realizar un cambio en nuestra unidad de análisis, a fin de conocer los valores totales para cada uno de los niveles  de una **variable categórica**. Para cumplir con esta tarea es necesario complementar el poder de la función **summarize()** con la función **group_by()**, esta permite modificar la unidad de análisis.

Es posible utilizar más  de una variable como argumento de la función **group_by()**.


```{r eval=FALSE}
msleep %>% 
  group_by(vore) %>% 
  summarise(n = n(),
            average = mean(sleep_total), 
            maximum = max(sleep_total))
```

```{r echo=FALSE}
msleep %>% 
  group_by(vore) %>% 
  summarise(n = n(),
            average = mean(sleep_total), 
            maximum = max(sleep_total)) %>% 
  kable()
```


**summarise()** puede utilizar como argumento cualquier función que resuma en un valor  una característica de un grupo de observaciones:

+ `n()` - determina el número de observaciones para cada uno de los niveles de una variable, **No es necesario especificar un argumento**.

+ `n_distinct(variable)` - determina el número de observaciones o niveles únicos de una **variable**.

+ `sum(variable)` suma, `max(variable)` máximo, `min(variable)` mínimo , ...

+ `mean(variable)`, `median(variable)`, `sd(variable)`, `IQR(variable)`, ... 


El ejemplo siguiente calcula el promedio de la variable **sleep_total** y lo divide por **24**, permitiéndonos determinar la proporción de horas de sueño por día. Esto para cada uno de los niveles de la variable **vore**.


```{r eval=FALSE}
msleep %>% 
  group_by(vore) %>% 
  summarise(avg_sleep_day = mean(sleep_total)/24)
```

```{r echo=FALSE}
msleep %>% 
  group_by(vore) %>% 
  summarise(avg_sleep_day = mean(sleep_total)/24) %>% 
  kable()
```


## **Variantes de la función summarize()**

Al igual que las funciónes **filter(), select() y mutate())**; **summarise()** tiene tres variantes que permiten trabajar sobre multiples columnas con un solo comando: 


### summarise_all()

Esta requiere como argumento una función conglomerante, la cual actuara sobre los elementos de una columna.

El siguiente ejemplo calcula el promedio de cada una de las columnas, en ocasiones será necesario incluir como argumento **na.rm = TRUE** para ignorar las observaciones con valores **NA**.   

- Sin considerar el argumento **na.rm**

```{r, eval=FALSE}
msleep %>% 
   select_if( is.numeric) %>%  
   summarise_all(mean) 
```

```{r echo=FALSE}
msleep %>% 
   select_if( is.numeric) %>%  
   summarise_all(mean) %>% 
  kable()
```

- Ignorando los valores **NA**

```{r, eval=FALSE}
msleep %>% 
   select_if( is.numeric) %>%  
   summarise_all(mean, narm = TRUE) 
```

```{r echo=FALSE}
msleep %>% 
   select_if( is.numeric) %>%  
   summarise_all(mean, na.rm = TRUE) %>% 
  kable()
```

Utilizando las funciones **group_by()** y **summarize()**. El siguiente ejemplo retorna el promedio de todas las variables para cada uno de los niveles de la variable **vore**. 

```{r eval=FALSE}
msleep %>% 
  group_by(vore) %>% 
  summarise_all(mean, na.rm = TRUE) %>% 
  select(-c(2:5))
```

```{r echo=FALSE}
msleep %>% 
  group_by(vore) %>% 
  summarise_all(mean, na.rm = TRUE) %>% 
  select(-c(2:5)) %>% 
  kable()
```

El argumento utilizado como instrucción para generar agrupar (resumir las observaciones)  tiene que ser una función. Cuando no se tenga una función predeterminada en el ambiente de R o como parte de un paquete, es posible construir una función anónima.

El siguiente ejemplo incremente en 5 al promedio de cada una de las columnas del data.frame. La función anónima que nos permita cumplir esta tarea puede ser construida de las siguientes formas: **funs(mean(., na.rm = TRUE) + 5)**, o : **~mean(., na.rm = TRUE) + 5**.


```{r eval=FALSE}
msleep %>%
  group_by(vore) %>% 
  summarise_all(~mean(., na.rm = TRUE) + 5) 
```

```{r echo=FALSE}
msleep %>%
  group_by(vore) %>% 
  summarise_all(~mean(., na.rm = TRUE) + 5) %>% 
  select(-c(2:5)) %>% 
  kable()
```


### summarise_if()

Esta función necesita dos argumentos:

+ Primero necesitamos información referente a las columnas que serán considerada. Esta información es obtenida mediante una función cuyos resultados son valores boléanos (**TRUE, FALSE**). Los funciones más  frecuentes: `is.numeric`, `is.integer`, `is.double`, `is.logical`, `is.factor`, `lubridate::is.POSIXt` o `lubridate::is.Date`.

+ Segundo, es necesaria una función conglomerante predeterminada (mean, sum, ...) o una función anónima construida con mediante la función **funs()** o el operador **~**.

El ejemplo retorna el promedio de todas las variables numéricas agrupadas mediante la variable `vore`:

```{r eval=FALSE}
msleep %>% 
  group_by(vore) %>% 
  summarise_if(is.numeric, mean, na.rm=TRUE)
```

```{r echo=FALSE}
msleep %>% 
  group_by(vore) %>% 
  summarise_if(is.numeric, mean, na.rm=TRUE) %>% 
  kable()
```


Uno de los puntos débiles de las funciones conglomerantes es que podemos estar expuestos a confusión, al no saber qué información es la que se obtiene como resultado. Afortunadamente la función `rename_*()` nos permite renombrar el nombre de cada una de las columnas:

```{r eval=FALSE}
msleep %>% 
  group_by(vore) %>% 
  summarise_if(is.numeric, mean, na.rm=TRUE) %>% 
  rename_if(is.numeric, ~paste0("promedio_", .))
```


```{r echo=FALSE}
msleep %>% 
  group_by(vore) %>% 
  summarise_if(is.numeric, mean, na.rm=TRUE) %>% 
  rename_if(is.numeric, ~paste0("promedio_", .)) %>% 
  select(1:4) %>% 
  kable()
```

### summarise_at()

Esta variante también requiere de dos argumentos: 

1. El nombre de las columnas que serán consideradas, estas deberán estar incluidos como argumentos de la función **vars()**.


2. Adicionalmente, es necesario indicar cual será la función conglomerante que actuara sobre las variables seleccionadas.


El ejemplo siguiente proporciona como resultado el promedio de los valores de las columnas cuyos nombres contengan la  palabra **sleep** y también renombran estas columnas **promedio_variable** para clarificar la información:


```{r eval=FALSE}
msleep %>%
  group_by(vore) %>% 
  summarise_at(vars(contains("sleep")), mean, na.rm=TRUE) %>%
  rename_at(vars(contains("sleep")), ~paste0("promedio_", .))
```

```{r echo=FALSE}
msleep %>%
  group_by(vore) %>% 
  summarise_at(vars(contains("sleep")), mean, na.rm=TRUE) %>% 
  rename_at(vars(contains("sleep")), ~paste0("promedio_", .)) %>% 
  kable()
```



### Ordenamiento de filas

En muchas oportunidades es útil que nuestras tablas de resumen estén ordenadas, la función **arrange()** nos permite cumplir con esta tarea. El resultado de esta función ordena los valores en forma ascendente, pero es posible también ordenarlos de forma descendente incluyendo la función **desc()**:


Ordenando variables numéricas:  
**arrange(sleep_total)** Ordena los tiempo en forma ascendente:


```{r eval=FALSE}
msleep %>% 
  group_by(vore) %>% 
  summarise(avg_sleep = mean(sleep_total)) %>% 
  arrange(avg_sleep)
```

```{r echo=FALSE}
msleep %>% 
  group_by(vore) %>% 
  summarise(avg_sleep = mean(sleep_total)) %>% 
  arrange(avg_sleep) %>% 
  kable()
```

El resultado opuesto puede ser obtenido mediante:

```{r eval=FALSE}
msleep %>% 
  group_by(vore) %>% 
  summarise(avg_sleep = mean(sleep_total)) %>% 
  arrange(avg_sleep)
```

```{r echo=FALSE}
msleep %>% 
  group_by(vore) %>% 
  summarise(avg_sleep = mean(sleep_total)) %>% 
  arrange(avg_sleep) %>% 
  kable()
```


Si los datos están siendo analizados en función de los niveles de alguna variable específica, es posible ordenarlos agregando el argumento **.by_group = TRUE** a la función **arrange()**:


```{r eval=FALSE}
msleep %>% 
  select(vore, sleep_total) %>% 
  group_by(vore) %>% 
  arrange(desc(sleep_total), .by_group = TRUE)
```

```{r echo=FALSE}
msleep %>% 
  select(vore, sleep_total) %>% 
  group_by(vore) %>% 
  arrange(desc(sleep_total), .by_group = TRUE) %>% 
  filter(vore == "carni") %>% 
  head() %>% 
  kable()
```

```{r echo=FALSE}
msleep %>% 
  select(vore, sleep_total) %>% 
  group_by(vore) %>% 
  arrange(desc(sleep_total), .by_group = TRUE) %>% 
  filter(vore == "herbi") %>% 
  head() %>% 
  kable()
```



- **Trabajando con partes de nuestro data.frame**

 En algunos casos nuestro objetivo es trabajar con partes de nuestros datos, algunas de las funciones que nos ayudaran con esta tarea:

### Los **n** valores más  altos y bajos:

Si deseas conocer los **5** valores más altos del promedio de la variable **sleep_total** 

```{r eval=FALSE}
msleep %>% 
  group_by(order) %>% 
  summarise(average = mean(sleep_total)) %>% 
  top_n(5) %>% 
  arrange(desc(average))
```

```{r echo=FALSE}
msleep %>% 
  group_by(order) %>% 
  summarise(average = mean(sleep_total)) %>% 
  top_n(5) %>% 
  arrange(desc(average)) %>% 
  kable()
```

Los `5` valores más bajos pueden ser recuperados con la ayuda de: `top_n(-5)`:

```{r eval=FALSE}
msleep %>% 
  group_by(order) %>% 
  summarise(average = mean(sleep_total)) %>% 
  top_n(-5) %>% 
  arrange(desc(average))
```

```{r echo=FALSE}
msleep %>% 
  group_by(order) %>% 
  summarise(average = mean(sleep_total)) %>% 
  top_n(-5) %>% 
  arrange(desc(average)) %>% 
  kable()
```


Si tienes más de una columna, es posible agregar como argumento el nombre de la variable de la cual se quiere recuperar la información:


```{r eval=FALSE}
msleep %>% 
  group_by(order) %>% 
  summarise(average_sleep = mean(sleep_total),
            max_sleep = max(sleep_total)) %>% 
  top_n(5, average_sleep)
```


```{r echo=FALSE}
msleep %>% 
  group_by(order) %>% 
  summarise(average_sleep = mean(sleep_total),
            max_sleep = max(sleep_total)) %>% 
  top_n(5, average_sleep) %>% 
  kable()
```

### Muestreo aleatoria de filas:


Mediante la función **sample_n()**  es posible tomar una muestra aleatoria de **n** filas de nuestro data.frame.


```{r eval=FALSE}
msleep %>% 
  sample_n(6) %>% 
  select_if(is.character)
```

```{r echo=FALSE}
msleep %>% 
  sample_n(6) %>% 
  select_if(is.character) %>% 
  kable()
```


Una variante de esta función nos permite recuperar una fracción de las filas del data.frame, **sample_frac()**. El siguiente ejemplo recupera el **10%** de las filas de nuestra base de datos.


```{r eval=FALSE}
msleep %>% 
  sample_frac(.1) %>% 
  select_if(is.numeric)
```

```{r echo=FALSE}
msleep %>% 
  sample_frac(.1) %>% 
  select_if(is.numeric) %>% 
  kable()
```


### Filas específicas:

Las funciones **head()** y **tail()** permiten recuperar las **6** primeras y últimas filas del data.frame, respectivamente. Esto puede ser modificado usando como argumento **n = x** en ambas funciones. 

Si deseamos examinar filas de la parte media de nuestro dataframe la función **slice()** nos permite recuperar estas filas. El ejemplo muestra cono recuperar las filas **50** a la **55**.


```{r eval=FALSE}
msleep %>% 
  slice(50:55) %>% 
  select(- c(2:5))
```

```{r echo=FALSE}
msleep %>% 
  slice(50:55) %>% 
  select(- c(2:5)) %>% 
  kable()
```



## Referencias:

1. Basado en el tutorial de [Suzan Baert](https://suzan.rbind.io/2018/04/dplyr-tutorial-4/): **Data Wrangling Part 4: Summarizing and slicing your data**


