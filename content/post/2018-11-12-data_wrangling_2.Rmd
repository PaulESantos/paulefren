---
title: "Data Wrangling Part 2"
subtitle: "Ordenando las columnas en forma adecuada"
author: "Paul Efren Santos Andrade"
date: 2018-11-12
categories: ["R"]
tags: ["R Markdown", "Data management"]
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE)
library(tidyverse)
library(knitr)
library(infer)
```


## La base de datos:

Continuaremos usando trabajando con la base de datos *msleep*, para facilitar la reproductibilidad y experimentacion del codigo.

```{r eval=FALSE}
library(tidyverse)

glimpse(msleep)
```


```{r echo=FALSE}
library(tidyverse)
 # Estructura:
glimpse(msleep)
```

## **mutate()**

- Como crear y transformar columnas:

Se puede crear columnas nuevas con la función *mutate()*. Las posibilidades dentro de esta función son innumerables, si la acción es aplicable a un vector normal puede ser realizada mediante esta función.

*mutate()* permite crear `nuevas columnas` (asignando un nombre nuevo a la columna), o reemplazar una columna existente (si se conserva el nombre).

La operación más básica para crear columnas nuevas, es realizar cálculos usando los valores de otra columna. Por ejemplo, podemos calcular el peso del cerebro en gramos.


```{r eval=FALSE}
msleep %>%
  select(name, sleep_total) %>%
  mutate(sleep_total_min = sleep_total * 60)
```

```{r echo=FALSE}
msleep %>%
  select(name, sleep_total) %>%
  mutate(sleep_total_min = sleep_total * 60) %>% 
  head() %>% 
  kable()
```


Las columnas nuevas pueden construirse usando como argumentos los resultados de funciones conglomerantes promedio (*mean()*), mediana (*median()*), máximo (*max()*), mínimo (*min()*), **....**


El siguiente ejemplo crea dos columnas nuevas: una muestra la diferencia de cada una de las observaciones respecto al tiempo de sueño promedio, la otra columna muestra la diferencia entre cada una de las observaciones y la observación con el valor mínimo. 


```{r eval=FALSE}
msleep %>%
  select(name, sleep_total) %>%
  mutate(
    sleep_total_vs_AVG = sleep_total - round(mean(sleep_total), 1),
    sleep_total_vs_MIN = sleep_total - min(sleep_total)
  )
```


```{r echo=FALSE}
msleep %>%
  select(name, sleep_total) %>%
  mutate(
    sleep_total_vs_AVG = sleep_total - round(mean(sleep_total), 1),
    sleep_total_vs_MIN = sleep_total - min(sleep_total)
  ) %>% 
  head() %>% 
  kable()
```


Si buscas aplicar funciones sobre múltiples columnas, es necesario agregar una función adicional a la línea de código que permita que la función tome como argumento los valores de cada una de las filas. *?rowwise()*.

```{r eval=FALSE}
msleep %>%
  select(name, contains("sleep")) %>%
  rowwise() %>%
  mutate(avg = mean(c(sleep_rem, sleep_cycle))) %>% 
  ungroup()
```

```{r echo=FALSE}
msleep %>%
  select(name, contains("sleep")) %>%
  rowwise() %>%
  mutate(avg = mean(c(sleep_rem, sleep_cycle))) %>% 
  ungroup() %>% 
  head() %>% 
  kable()
```



La función `ifelse()` es muy útil si se busca modificar los datos de una columna de acuerdo a una condición. Esta función toma como primer argumento **un condicional lógico**; el segundo argumento determina la acción a realizarse, si el resultado del condicional es verdadero (**TRUE**) y el tercer argumento especifica la acción en caso el condicional sea falso (**FALSE**).


 Imagines que la base de datos contiene dos valores atípicos y deseamos excluir estos. El siguiente ejemplo evalúa la variable **brainwt** y crea la variable **brainwt2** en la cual remplaza todo valor mayor a `4` con `NA`.

```{r eval=FALSE}
msleep %>%
  select(name, brainwt) %>%
  mutate(brainwt2 = ifelse(brainwt > 4, NA, brainwt)) %>%
  arrange(desc(brainwt))
```

```{r echo=FALSE}
msleep %>%
  select(name, brainwt) %>%
  mutate(brainwt2 = ifelse(brainwt > 4, NA, brainwt)) %>%
  arrange(desc(brainwt)) %>% 
  head() %>% 
  kable()
```


- Modificar múltiples columnas al mismo tiempo:

Las variantes de la función **mutate()** permiten ampliar nuestras habilidades para modificar o crear nuevas columnas:


## **mutate_all()**

La variante  `mutate_all()` es la más simple. Solo es necesario usar como argumento la función que deseas aplicar sobre las columnas.

Por ejemplo: Podemos modificar todas las observaciones de almacenadas el variables de tipo carácter que combinan mayúsculas y minúsculas, a mayúsculas únicamente.

```{r eval=FALSE}
msleep %>%
  select_if(~is.character(.)) %>% 
  mutate_all(toupper)
```

```{r echo=FALSE}
msleep %>%
  select_if(~is.character(.)) %>% 
  mutate_all(toupper) %>% 
  head() %>% 
  kable()
```


## **mutate_if()**

No todas las tareas de modificación y ordenamiento de datos pueden ser realizadas mediante `mutate_all()`. Por ejemplo si queremos utilizar la función `round()`  como argumento de muatate_all(), tendremos como resultado un error. Esto debido a que la base de datos contiene variables de tipo carácter y numérico.

```{r eval=FALSE}
msleep %>%
  mutate_all(round)
```

`Error in mutate_impl(.data, dots) : 
  Evaluation error: non-numeric argument to mathematical function. `

En este caso es necesario agregar una condicional que evalué si los datos son de tipo numérico antes  de que la función `round()` sea aplicada, esta tarea puede ser desarrollada mediante la función  *mutate_if()*.


La función `mutate_if()` necesita dos argumentos:

- Primero es necesario obtener información de las columnas que se desean considerar. Esta información es dada por una función que retorna valores lógicos: `is.numeric`, `is.integer`, `is.double`, `is.logical`, `is.factor`, `lubridate::is.POSIXt` o `lubridate::is.Date`.

- El siguiente argumento, son las instrucciones de modificación de los datos en forma de función.


```{r eval=FALSE}
msleep %>%
  select(name, sleep_total:bodywt) %>%
  mutate_if(is.numeric, round)
```

```{r echo=FALSE}
msleep %>%
  select(name, sleep_total:bodywt) %>%
  mutate_if(is.numeric, round) %>% 
  head() %>% 
  kable()
```


## **mutate_at()**

La funcion `mutate_at()` permite modificar columnas especificas, esta necesita los siguientes argumentos:

+ Es necesario determinara las columnas que seran consideradas. Las variantes de la la funcion `select()` ayudan con esta tarea, adicionalmente se tiene la funcion `vars()`.

+ El siguiente elemento de la funcion, sera las instruciones de modificacion.


Por ejemplo, las mediciones de tiempo de sueño están expresadas en horas, pero queremos mostrarlas en minutos. Se puede usar la función `mutate_at()`,  primero utilizaremos las funciones `vars()`  y `contains()` para seleccionar  las columnas. Para culminar la tarea es necesario construir una función anónima con ayuda de `funs()`, la cual que permita multiplicar cada valor por 60.


```{r eval=FALSE}
msleep %>%
  select(name, sleep_total:awake) %>%
  mutate_at(vars(contains("sleep")), ~(.*60))
```

```{r echo=FALSE}
msleep %>%
  select(name, sleep_total:awake) %>%
  mutate_at(vars(contains("sleep")), ~(.*60)) %>% 
  head() %>% 
  kable()
```


- **Cambio de nombres de las columnas después de la modificación de sus valores**

La función  `mutate()`, permite modificar los nombres de las columnas en un solo paso. 
En el ejemplo anterior pude llevar a confusiones la modificación de las unidades que realizamos, podemos modificar el nombre de las columnas añadiendo esta información mediante la función `rename`.


```{r eval=FALSE}
msleep %>%
  select(name, sleep_total:awake) %>%
  mutate_at(vars(contains("sleep")), ~(.*60)) %>% 
  rename_at(vars(contains("sleep")), ~paste0(.,"_min"))
```

```{r}
msleep %>%
  select(name, sleep_total:awake) %>%
  mutate_at(vars(contains("sleep")), ~(.*60)) %>% 
  rename_at(vars(contains("sleep")), ~paste0(.,"_min")) %>% 
  head() %>% 
  kable()
```


O como lo señaló [Tomas McManus:](https://twitter.com/TomasMcManus1/status/981187099649912832) se puede asignar una "etiqueta" dentro de la función  `funs ()` la cual se agregará al nombre actual. El resultado obtenido mediante la función `funs ()` agrega las columnas nuevas en lugar de reemplazarlas. Esto es útil dependiendo de los objetivos del análisis que se esté desarrollando.


```{r, eval=FALSE}
msleep %>%
  select(name, sleep_total:awake) %>%
  mutate_at(vars(contains("sleep")), funs(min = .*60))
```

```{r echo=FALSE}
msleep %>%
  select(name, sleep_total:awake) %>%
  mutate_at(vars(contains("sleep")), funs(min = .*60)) %>% 
  head() %>% 
  kable()
```



- **Columnas de tipo caracter**

## **recode()**

En ocasiones es necesario modificar los valores de las variables discretas, la función `recode()` puede ser utilizada como un argumento de `mutate()` para cumplir la tarea de modificar los niveles de una   variable o agregarlos en un menor número de niveles.

La opción `.default` hace referencia a todos los valores que no son considerados por los niveles especificados, excepto *NA*. Se puede modificar los valores NA mediante la opción  `.missing`.

```{r eval=FALSE}
msleep %>%
  mutate(conservation2 = recode(conservation,
                        "en" = "Peligro de extincion",
                        "lc" = "Riesgo menor",
                        "domesticated" = "Riesgo menor",
                        .default = "No conocido",
                        .missing = "Falta informacion")) %>%
  count(conservation2)
```

```{r echo=FALSE}
msleep %>%
  mutate(conservation2 = recode(conservation,
                        "en" = "Peligro de extincion",
                        "lc" = "Riesgo menor",
                        "domesticated" = "Riesgo menor",
                        .default = "No conocido",
                        .missing = "Falta informacion")) %>%
  count(conservation2) %>% 
  kable()
```


`recode()` tiene una variante especial para determinar que las variables sean consideradas de tipo factor `recode_factor()`. En esta función la opción `.ordered` por defecto es `FALSE`, para obtener una secuencia de los niveles de un factor esta  debe ser modificada a  `TRUE`:


```{r eval=FALSE}
msleep %>%
  mutate(conservation2 = recode_factor(conservation,
                        "en" = "Peligro de extincion",
                        "lc" = "Riesgo menor",
                        "domesticated" = "Riesgo menor",
                        .default = "No conocido",
                        .missing = "Falta informacion",
                        .ordered = TRUE)) %>%
  count(conservation2)
```

```{r echo=FALSE}
msleep %>%
  mutate(conservation2 = recode_factor(conservation,
                        "en" = "Peligro de extincion",
                        "lc" = "Riesgo menor",
                        "domesticated" = "Riesgo menor",
                        .default = "No conocido",
                        .missing = "Falta informacion",
                        .ordered = TRUE)) %>%
  count(conservation2) %>% 
  kable()
```



## **if_else()**

La función `ifelse()` puede ser usada para convertir una variable con múltiples niveles y agregarlos en solo dos niveles en una nueva variable. 

Por ejemplo, podemos crear una variable discreta con los siguientes niveles **Largo** y **Corto**, con base en el tiempo de sueño total (**sleep_total**).    


```{r eval=FALSE}
msleep %>%
  select(name, sleep_total) %>%
  mutate(sleep_time = ifelse(sleep_total > 10, "Largo", "Corto")) 
```

```{r echo=FALSE}
msleep %>%
  select(name, sleep_total) %>%
  mutate(sleep_time = ifelse(sleep_total > 10, "Largo", "Corto")) %>% count(sleep_time) %>%
  kable()
```


## **case_when()**

`case_when()` permite evaluar múltiples condicionales lógicos para crear nuevos niveles de una variable discreta. Para todos los valores que no son considerados en los condicionales la opción `TRUE ~ "nuevo_nombre"`, permite otorgarles una categoría.

```{r eval=FALSE}
msleep %>%
  select(name, sleep_total) %>%
  mutate(
    sleep_total_discr = case_when(
      sleep_total > 13 ~ "Prolongado",
      sleep_total > 10 ~ "Largo",
      sleep_total > 7 ~ "Limitado",
      TRUE ~ "Corto"
    )
  ) %>%
  mutate(sleep_total_discr = factor(
    sleep_total_discr,
    levels = c("Corto", "Limitado",
               "Largo", "Prolongado")
  )) %>% 
  count(sleep_total_discr)
```

```{r echo=FALSE}
msleep %>%
  select(name, sleep_total) %>%
  mutate(
    sleep_total_discr = case_when(
      sleep_total > 13 ~ "Prolongado",
      sleep_total > 10 ~ "Largo",
      sleep_total > 7 ~ "Limitado",
      TRUE ~ "Corto"
    )
  ) %>%
  mutate(sleep_total_discr = factor(
    sleep_total_discr,
    levels = c("Corto", "Limitado",
               "Largo", "Prolongado")
  )) %>% 
  head() %>% 
  kable()
```


La función `case_when()` puede evaluar condicionales en más de una columna:

```{r eval=FALSE}
msleep %>%
  mutate(
    silly_groups = case_when(
      brainwt < 0.001 ~ "Peso_cerebro_ligero",
      sleep_total > 10 ~ "Sueño_prolongado",
      is.na(sleep_rem) ~ "Ausencia_rem",
      TRUE ~ "Otros"
    )
  ) %>%
  count(silly_groups)
```

```{r echo=FALSE}
msleep %>%
  mutate(
    silly_groups = case_when(
      brainwt < 0.001 ~ "Peso_cerebro_ligero",
      sleep_total > 10 ~ "Sueño_prolongado",
      is.na(sleep_rem) ~ "Ausencia_rem",
      TRUE ~ "Otros"
    )
  ) %>%
  count(silly_groups) %>% 
  kable()
```


## **Separar y unir columnas**

Usaremos el siguinete dataframe como ejemplo:

```{r message=FALSE, warning=FALSE,  echo=FALSE, include=FALSE}
conservation_expl <- data_frame(conservation_abbreviation = 
c("EX = Extinct",
"EW = Extinct in the wild",
"CR = Critically Endangered",
"EN = Endangered",
"VU = Vulnerable",
"NT = Near Threatened",
"LC = Least Concern",
"DD = Data deficient",
"NE = Not evaluated",
"PE = Probably extinct (informal)",
"PEW = Probably extinct in the wild (informal)"))
```

```{r echo=FALSE}
conservation_expl %>% 
  kable()
```

Se puede separar los elemento de una columna mediante la función `separate()`. Los argumentos de esta función son: el nombre de la columna a separar, los nombres de las nuevas columnas y el elemento usado como separador.

El siguiente ejemplo separa la columna usando como separador `=`.


```{r eval=FALSE}
conservation_table <- conservation_expl %>%
  separate(
    conservation_abbreviation,
    into = c("abbreviation", "description"),
    sep = " = "
  )
conservation_table
```

```{r echo=FALSE}
 conservation_expl %>%
  separate(
    conservation_abbreviation,
    into = c("abbreviation", "description"),
    sep = " = "
  ) %>% 
  kable()
```


La función `unite()` realiza la tarea opuesta. Debe especificarse el nombre de la columna nueva, los nombres de las columnas a ser unidas y finalmente el separador que será usado.


```{r eval=FALSE}
conservation_table %>%
  unite(united_col, abbreviation, description, sep=": ")
```

```{r echo=FALSE}
 conservation_expl %>%
  separate(
    conservation_abbreviation,
    into = c("abbreviation", "description"),
    sep = " = "
  ) %>%
  unite(united_col, abbreviation, description, sep=": ") %>% 
  kable()
```


## **spread() - gather()**

La función `gather()` permite reunir múltiples columnas en una. En este ejemplo tenemos tres columnas que contienen información sobre el tiempo de sueño. Para realizar algunos análisis y construir gráficos puede ser necesario tener toda esta información en una sola columna.

Esta función necesita como primer argumento el nombre de la nueva columna (`"key"`), seguido de un nombre para la columna que almacenara los valores de cada observación (`"value"`). Las columnas que no deseas unir debe de ser deseleccionadas mediante `-`.


```{r eval=FALSE}
msleep_g <- msleep %>%
  select(name, contains("sleep")) %>%
  gather(key = "sleep_measure", value = "time", -name)

msleep_g
```

```{r echo=FALSE}
msleep %>%
  select(name, contains("sleep")) %>%
  gather(key = "sleep_measure", value = "time", -name) %>% 
  head() %>% 
  kable()
```


La función `spread()` permite desarrollar la tarea opuesta, separar una columna en múltiples columnas.


```{r eval=FALSE}
msleep_g %>%
  spread(sleep_measure, time)
```

```{r echo=FALSE}
msleep %>%
  select(name, contains("sleep")) %>%
  gather(key = "sleep_measure", value = "time", -name) %>% 
  spread(sleep_measure, time) %>% 
  head() %>% 
  kable()
```

## Referencias:

1. Basado en el tutorial de [Suzan Baert](https://suzan.rbind.io/2018/02/dplyr-tutorial-2/): **Data Wrangling Part 2: Transforming your columns into the right shape**


