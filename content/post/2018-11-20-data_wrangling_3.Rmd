---
title: "Data Wrangling Part 3"
subtitle: "Comandos básicos para la selección de observaciones"
author: "Paul Efren Santos Andrade"
date: 2018-11-21
categories: ["R"]
tags: ["R Markdown", "Data management"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, error = FALSE, warning=FALSE)
library(tidyverse)
library(knitr)
```

Esta es la tercera parte de la serie Data Wrangling.

## Las librerias:

```{r eval=FALSE}
library(tidyverse)
```


## La base de datos:

Continuaremos trabajando con la información contenida en la base de datos  **msleep**. Con la finalidad de facilitar la reproductibilidad del código usado en este tutorial.

```{r eval=FALSE}
data("msleep")
glimpse(msleep)
```

```{r echo=FALSE}
data(msleep)
glimpse(msleep)
```

## **filter()**

En muchos de los casos no es necesario considerar todas las filas de nuestros **data.frame** y solo deseamos enfocarnos en un grupo de estas. La función que nos permite recuperar  filas especificas es **filter()**.
El esquema general de esta función es:
`filter(data.frame, condición)`

### **Selección de observaciones incluidas en variables numéricas**

Se puede seleccionar observaciones de variables numéricas con base en sus valores. Los operadores más usados para esta tarea son:`>`, `>=`, `<`, `<=`, `==` y `!=`. 

```{r eval=FALSE}
msleep %>% 
  select(name, sleep_total) %>% 
  filter(sleep_total > 18)
```

```{r echo=FALSE}
msleep %>% 
  select(name, sleep_total) %>% 
  filter(sleep_total > 18) %>% 
  head() %>% 
  kable()
```

Si deseas recuperar un rango de valores, es posible usar dos condiciones lógicas. Por ejemplo, si se desea seleccionar todos los animales cuyo tiempo de sueño total varía entre 15 y 18 horas, **filter(sleep_total>=16, sleep_total <=18)**, una opción corta para cumplir con esta tarea es la función **between()**. 


```{r eval=FALSE}
msleep %>% 
  select(name, sleep_total) %>% 
  filter(between(sleep_total, 16, 18))
```

```{r echo=FALSE}
msleep %>% 
  select(name, sleep_total) %>% 
  filter(between(sleep_total, 16, 18)) %>% 
  head() %>% 
  kable()
```


Otra función útil es **near()**, esta permite recuperar todos los elementos cercanos a un valor determinado. Esta función requiere que se especifique un valor de tolerancia, el cual indicara los límites de la selección. Se puede utilizar un valor predeterminado como valor de tolerancia: **filter(near(sleep_total, 17, tol = .5))** esta recuperara todos los valores entre **16.5** y **17.5**, o un valor que sea resultado de una función.

El siguiente ejemplo recupera todas las filas cuyos valores varían entre 17 **+/-** la desviación estándar (**sd()**)de la variable tiempo total de sueño. 

```{r eval=FALSE}
msleep %>% 
  select(name, sleep_total) %>% 
  filter(near(sleep_total, 17, tol = sd(sleep_total)))
```

```{r echo=FALSE}
msleep %>% 
  select(name, sleep_total) %>% 
  filter(near(sleep_total, 17, tol = sd(sleep_total))) %>% 
  head() %>% 
  kable()
```


### **Selección de observaciones en variables de tipo carácter**

Si deseas enfocarte en un grupo especio de animales, es necesario utilizar el operador **==**.

```{r eval=FALSE}
msleep %>% 
  select(order, name, sleep_total) %>% 
  filter(order == "Didelphimorphia")
```

```{r echo=FALSE}
msleep %>% 
  select(order, name, sleep_total) %>% 
  filter(order == "Didelphimorphia") %>% 
  head() %>% 
  kable()
```


Otros operadores usados:
  
**filter(order != "Rodentia")** selecciona todas las observaciones diferentes a **Rodentia**.
 
**filter(name > "v")** selecciona las observaciones cuyos nombres(`name`) inician con las letras que seguin a la "v".


Si deseas recuperar más de un elemento, el operador **%in%** permite realizar esta tarea. El siguiente ejemplo, selecciona las filas con información de animales pertenecientes a los órdenes **Didelphimorphia** y **Diprotodontia**.


```{r eval=FALSE}
msleep %>% 
  select(order, name, sleep_total) %>% 
  filter(order %in% c("Didelphimorphia", "Diprotodontia"))
```

```{r echo=FALSE}
msleep %>% 
  select(order, name, sleep_total) %>% 
  filter(order %in% c("Didelphimorphia", "Diprotodontia")) %>% 
  head() %>% 
  kable()
```


También puedes usar el operador **%in%** para ignorar ciertos grupos. Para cumplir esta tarea se deberá agregar el operador **!**  negación como primer argumento de la función **filter()**.


```{r eval=FALSE}
remove <- c("Rodentia", "Carnivora", "Primates")

msleep %>% 
  select(order, name, sleep_total) %>% 
  filter(!order %in% remove)
  
```

```{r echo=FALSE}
remove <- c("Rodentia", "Carnivora", "Primates")

msleep %>% 
  select(order, name, sleep_total) %>% 
  filter(!order %in% remove) %>% 
  head() %>% 
  kable()
```

### **Selección de observaciones con base en múltiples condiciones**

Los ejemplos anteriores seleccionan las filas con base en una sola condición, pero **filter()** permite otros tipos de condiciónales:  

+ `filter(condición1, condición2)` devolverá como resultado las filas que cumplan ambas condiciones. 

+ `filter(condición1, !condición2)` obtendrá como resulta las filas para las cuales se cumple la condición uno mas no la condición dos.

+ `filter(condición1 | condición2)` retornara las filas que cumplan las dos condiciones.  


+ `filter(xor(condición1, condición2)` obtendrá como resultado las filas en las que cumplan solo una de las condiciones.

Múltiples condiciónales pueden ser combinados **y**, **o** y **no**. El ejemplo selecciona todas las filas en las cuales la variable **bodywt** es mayor a **100** y  con un valor de la variable **sleep_total** mayor a **15** que no pertenezcan al orden **Carnívora**.


```{r eval=FALSE}
msleep %>%
  select(name, order, sleep_total:bodywt) %>%
  filter(bodywt > 100,
         (sleep_total > 15 | order != "Carnivora"))
  
```

```{r echo=FALSE}
msleep %>%
  select(name, order, sleep_total:bodywt) %>%
  filter(bodywt > 100,
         (sleep_total > 15 | order != "Carnivora")) %>% 
  kable()
  
```

**xor()**

```{r eval=FALSE}
msleep %>%
  select(name, bodywt:brainwt) %>% 
  filter(xor(bodywt > 100, brainwt > 1))
```

```{r echo=FALSE}
msleep %>%
  select(name, bodywt:brainwt) %>% 
  filter(xor(bodywt > 100, brainwt > 1)) %>% 
  kable()
```

**El operador negación(!):**

El siguiente ejemplo devuelve las filas en las cuales la variable **brainwt** es mayor a 1, pero las variable **bodywt** no sea mayor a **100**.

```{r eval=FALSE}
msleep %>% 
  select(name, sleep_total, brainwt, bodywt) %>% 
  filter(brainwt > 1, !bodywt > 100)
```


```{r echo=FALSE}
msleep %>% 
  select(name, sleep_total, brainwt, bodywt) %>% 
  filter(brainwt > 1, !bodywt > 100) %>% 
  kable()
```

### **Filtrando las filas cuyas observaciones no contienen información (*NA*)**

Si buscamos ignorar las filas que no contienen información es necesario combinar: el operador **!** y la función **is.na()**, para usarlo como un argumento de la función **filter()**. 

El siguiente ejemplo retira todas las filas de la variable **conservation** cuyo valor es **NA**.


```{r eval=FALSE}
msleep %>% 
  select(name, conservation:sleep_cycle) %>% 
  filter(!is.na(conservation))
```

```{r echo=FALSE}
msleep %>% 
  select(name, conservation:sleep_cycle) %>% 
  filter(!is.na(conservation)) %>% 
  head() %>% 
  kable()
```


### **Filtros en múltiples columnas**


**dplyr** ofrece una serie de variantes de la función **filter()** que actúan sobre múltiples columnas: 

+ `Filter_all` actúa sobre todas las columnas. 
+ `Filter_if` y `filter_at` actúa sobre un grupo específico de columnas. 

Estas opciones tienen una formula general básica: primero es necesario especificar las columnas con las cuales se trabajara, seguida de la condición utilizada como filtro. En muchos casos será necesario el operador **.** como parte de la condición para hacer referencia  los valores que estamos buscando.


### **filter_all()**

El ejemplo selecciona todas las filas que contengan los caracteres **Ca** en los valores de cualquiera de las columnas. 


```{r eval=FALSE}
msleep %>% 
  select(name:order, sleep_total, -vore) %>% 
  filter_all(any_vars(str_detect(., pattern = "Ca")))
```

```{r echo=FALSE}
msleep %>% 
  select(name:order, sleep_total, -vore) %>% 
  filter_all(any_vars(str_detect(., pattern = "Ca")))
```


El siguiente código selecciona todas las filas que contengan valores menores a **0.1**:

```{r eval=FALSE}
msleep %>%  
  select(name, sleep_total:bodywt) %>% 
  filter_all(any_vars(. < 0.1))
```

```{r echo=FALSE}
msleep %>% 
  select(name, sleep_total:bodywt) %>% 
  filter_all(any_vars(. < 0.1)) %>% 
  head() %>% 
  kable()
```


El comando **any_vars()** es equivalente a al condicional **o**, así el comando **all_vars()** es equivalente al condicional **y**.

El siguiente ejemplo devuelve todas las filas en las cuales los valores de sus observaciones sean mayores a **1**.


```{r eval=FALSE}
msleep %>%  
  select(name, sleep_total:bodywt, -awake) %>% 
  filter_all(all_vars(. > 1))
  
```

```{r echo=FALSE}
msleep %>%  
  select(name, sleep_total:bodywt, -awake) %>% 
  filter_all(all_vars(. > 1)) %>% 
  kable()
```

### **filter_if()**

Nos permite especificar sobre qué tipo de variables se aplicara la fusión. El siguiente ejemplo actúa únicamente sobre las filas de las variables de tipo carácter que no contengan información (**NA**).

```{r eval=FALSE}
msleep %>% 
  select(name:order, sleep_total:sleep_rem) %>% 
  filter_if(is.character, any_vars(is.na(.)))
```


```{r echo=FALSE}
msleep %>% 
  select(name:order, sleep_total:sleep_rem) %>% 
  filter_if(is.character, any_vars(is.na(.))) %>% 
  kable()
```

De forma semejante es posible utilizar los siguientes funciones para especificar sobre qué tipo de variable actuara el filtro: `is.numeric`, `is.integer`, `is.double`, `is.logical`, `is.factor`, `is.POSIXt` o `is.Date`.


### **filter_at()**

Una de las funciones más útiles es **filter_at()**: es necesario seleccionar las columnas sobre las cuales actuara el filtro mediante el argumento **vars()**.  El siguiente argumento es la condición mediante la cual se filtraran las filas, es posible usar `all_vars()` si la condición es cumplida en todas las columnas, o `any_vars()` si solo una de las variables cumple con la condición.  

Por ejemplo, el siguiente código actúa sobre las variables **sleep_total** y **sleep_rem**, seleccionando las filas si los valores de las observaciones de ambas variables son mayores a **5**.

```{r eval=FALSE}
msleep %>% 
  select(name, sleep_total:sleep_rem, brainwt:bodywt) %>% 
  filter_at(vars(sleep_total, sleep_rem), all_vars(.>5))
```


```{r echo=FALSE}
msleep %>% 
  select(name, sleep_total:sleep_rem, brainwt:bodywt) %>% 
  filter_at(vars(sleep_total, sleep_rem), all_vars(.>5)) %>% 
  kable()
```


Otra forma de seleccionar las variables sobre las cuales actuara el filtro:

```{r eval=FALSE}
msleep %>% 
  select(name, sleep_total:sleep_rem, brainwt:bodywt) %>% 
  filter_at(vars(contains("sleep")), all_vars(.>5))
```


```{r echo=FALSE}
msleep %>% 
  select(name, sleep_total:sleep_rem, brainwt:bodywt) %>% 
  filter_at(vars(contains("sleep")), all_vars(.>5)) %>% 
  kable()
```


## Referencias:

1. Basado en el tutorial de [Suzan Baert](https://suzan.rbind.io/2018/02/dplyr-tutorial-3/): **Data Wrangling Part 3: Basic and more advanced ways to filter rows**


